### 스트림 병렬화는 주의해서 적용하라

병렬화(동시성 프로그래밍) 과 관련된 작업이라면 *안정성* 과 *응답 가능 상태*를 유지하는데 중요하게 생각해야 한다.

#### 병렬화를 쓰면 안되는 경우

- 파이프 라인(스트림)에서 iterate 를 쓰는 경우, limit 를 쓰는 경우
    - 스트림 라이브러리가 파이프라인을 병렬화 하는 방법을 찾지 못한다.
        - CPU 90%나 잡아먹는 상태가 무한히 계속된다.
    - limit 를 다룰 때 **CPU 코어가 남는다면 원소를 몇 개 더 처리한 후 limit 만큼의 갯수 이후의 결과를 버려도 아무런 해가 없다고 가정한다.**
        - 하지만 원소를 몇 개 더 처리하는 과정이 엄청 많은 비용이 든다면 성능이 오히려 더 끔찍하게 나빠질 수 있다.
        - 그래서 이 순진무결해 보이는 파이프라인은 자동 병렬화 알고리즘이 제 기능을 못하게 마비시킨다.
- 종단 연산을 잘 못 쓰는 경우  (순차적인 연산인 경우, 가변 축소 인경우는 안됨)
    - 가변 축소는 컬렉션을 합치는 비용이 크기 떄문이다.
- 참조 지역성이 좋지 않은 자료구조를 썻을 때

#### 병렬화 효과를 극대화 하는 경우

- `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap` 의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.
    - 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있다는 점
        - 다수의 스레드에 분배하기 좋은 특징 !
    - 참조 지역성이 뛰어난다는 점
        - `참조 지역성`: 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있다는 뜻
            - 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 대부분 시간을 멍하게 보내게된다.
- 스트림의 종단연산 중 가장 적합한 것은 하나로 합치는 작업 (reduction), reduce, min, max, count, sum 이다.
- anyMatch, allMatch, noneMath 등 맞으면 바로 반환하는 메서드

- reduce 연산은 누적기 (ACC accumulator)와 결합기 (combiner) 함수는 반드시 결합법칙을 만족하고 간섭받지 않고 상태를 갖지 않아야 한다.


병렬화 작업이 순서가 올바르지 않을 수 있는데, 이때는 forEachOrdered 를 사용하면 된다.


```
단일을 처리하는 랜덤과 여러개를 처리하는 랜덤이 각각 따로 있다.
단일: ThreadLocalRandom
여러개: SplittableRandom
```
