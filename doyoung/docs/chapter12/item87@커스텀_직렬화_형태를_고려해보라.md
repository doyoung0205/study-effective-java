### 커스텀 직렬화 형태를 고려해보라

먼저 고민해보고 괜찮다면 기본 직렬화 형태를 사용하라.

기본 직렬화 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다.

일반적으로 여러분이 직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다.
(객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다 - 객체 참조가 있는 클래스가 아닌 경우)

#### 기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제동해야 할 때가 많다.

private 이라도 @serial 어노테이션을 통해서 자바독을 통해 알려주자.

### 객체의 물리적 표현과 논리적 표현의 차이가 클 때

1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다. (내부적으로 LinkedList 를 사용했다면 영구히 써야 한다.)
2. 너무 많은 공간을 차지할 수 있다. (엔트리와 연결 정보는 내부 구현에 해당하니 직렬화 형태에 포함할 가치가 없지만 직렬화 형태는 포함하기에 너무 커진다.)
3. 시간이 너무 많이 걸릴 수 있다.
4. 스택 오버 플로를 일으킬 수 있다.

#### 이럴 떈 transient 한정자와 writeObject, readObject 메서드를 이용하자

- transient: 해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않는다는 표시다. (해당 필드들은 기본값으로 초기화)

writeObject, readObject 메서드 모두 defaultWriteObject 와 defaultReadObject 를 호출한다.
직렬화 명세에는 이 작업을 무조건 하라고 요구한다.

#### readObject

구버전 readObject 메서드에서 defaultReadObject 를 호출하지 않는다면 역직렬화 할 때 StreamCorruptedException 이 발생한다.

### writeObject

defaultWriteObject 에서 transient 한정자로 인해 기본 값으로 초기화 되는 부분이 있으니 별도로 초기화를 진행하자.

- <동기화 주의>
  객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.
  동기화 메커니즘은 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 따라야 한다. 그렇지 않으면 `자원 순서 교착 상태` 에 빠질 수 있다.

#### 어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.


이렇게 부여하면 잠재적이 호환성 문제가 사라지며 성능도 조금 빨라진다. 
런타임에 이 값을 생성하느라 복잡한 연산을 수행하기 때문이다.

```private static final long serialVersionUID = 1L; // 어떠한 long 값이든 상관없다. ```

기존 버전 클래스와의 호환성을 끊고 싶다면 단순히 직렬 버전 UID의 값을 바꿔주면 된다.
이렇게 하면 기존 버전의 직렬화된 인스턴스를 역직렬화할 때 `InvalidClassException` 이 던져질 것이다.

**구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID 를 절대 수정하지 말자.**
