## private 생성자나 열거 타입으로 싱글턴임을 보증하라

> 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다. ??

Q. AccessibleObject.setAccessible() 을 사용해 private 생성자를 호출할 수 있다.

A. 두 번째 객체가 생성되려 할 떄 예외를 던짐

### 1. public static final 필드 방식의 싱글턴

Elvis.INSTANCE 를 초기화할 때 딱 한 번만 호출된다.

### 2. 정적 팩터리 방식의 싱글턴'

#### 1번 보다 장점

- API (getInstance) 를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다는 점, 스레드 별로 다른 인스턴스를 넘겨주게 할 수 있다.
- 제네릭 싱글턴으로 만들 수 있다. (item30)
- 정적 펙토리를 참조하여 공급자로 만들 수 있다는 점

#### 1번과 2번의 단점

직렬화를 하려면 단순히 Serializable 을 구현한다고 선언하는 것만으로 부족

모든 인스턴스 필드를 일시적(transient) 이라고 선언하고 readResolve 메서드를 제공해야 한다.

그렇지 않으면 직렬화된 인스턴스를 역직렬화 할 때 마다 새로운 인스턴스가 만들어진다.

### 3. 열거 타입 방식의 싱글턴 - 바람직한 방법

대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.

하지만 상속해야 한다면 이 방법을 사용할 수 없다.

### 궁금한 것들

- 메서드 공급자? (item43, item44)
- 직렬화 역직렬화가 뭐지? (12장) -> 30페이지분량
- 제네릭 싱글턴이 뭐지? (item30)

- private static final 변수 들은 초기화 할때 딱 한번 -> 시스템 로딩 때 딱한번
- 두 번째 객체가 생성되려 할 떄 예외 어떻게 던짐?
```
private Elvis () {
    if(Objects.nonNull(INSTANCE)){
        throws new RuntimeException();
    }
}
```
- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.
Mockito 에서 mock 객체를 만들때 정적 메서드로는 생성하기 어렵기 때문이다.
https://ssoco.tistory.com/65

