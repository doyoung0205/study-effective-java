## 제네릭과 가변인수를 함께 쓸 때는 신중하라

### 가변인수의 허점

- 가변인수(varargs) : 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는 것.

가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.

그 결과 varargs 매개변수에 **제네릭이나 매개변수화 타입이 포함**되면 `힙 오염 (heep pollution)` 경고를 발생한다.

실체화 불가 타입은 런타임에는 컴파일 타임보다 타입 관련 정보를 적게 담고 있고 거의 모든 제네릭과 매개변수화 타입은 실체화 되지 않기 때문이다.

매개변수화 타입의 변수가 다른 타입의 객체를 참조하면 힙 오염이 발생한다.

이렇게 다른 타입 객체를 참조하는 상황에서는 컴파일러가 자동 생성한 형변환이 실패할 수 있으니,

제네릭 타입 시스템이 약속한 타입 안전성의 근간이 흔들려버린다.

```
static void dangerous(List<String>... stringLists) {
    List<Integer> intList = List.of(42);
    Object[] objects = stringLists;
    objects[0] = intList; // 힙 오염 발생
    String s = stringLists[0].get(0); // ClassCastException
}
```

### 그럼에도 불구하고 가변인수는 유용하다.

`List.of`, `Arrays.asList`, `Collections.addAll`, `EnumSet.of` 같은 메서드들을 자바라이브러리에서 제공한다.

다행힌 점은 앞서 보여준 위험한 메서드와는 달리 이들은 타입이 안전하다.

따라서 호출자에게서 발생하는 경고가 필요없는데 이때 `@SuppressWarnings("unchecked")` 를 통해서 경고를 무시할 수 있다.

하지만 이는 가변인자 뿐만 아니라 다른 진짜 문제도 숨길 수 있어 `SafeVarargs` 에너테이션를 사용하는 것이 좋다.

다만, 꼭 타입이 안전한 경우에만 사용할 수 있다.

### 가변인자 타입이 안전한지 어떻게 알 수 있을까?

가변인수 가 배열로 만들어 지고 난 뒤에 밖으로 노출 되지 않는 다면 안전하다고 할 수 있다.

- 신뢰할 수 없는 코드가 배열에 접근할 수 없다면 타입이 안전하다.

- 가변인자가 호출자로부터 그 메서드로 순순하게 인수들을 전달하는 일만 한다면 안전하다고 할 수 있다.

#### 주의사항 object 배열

타입 매개변수화 된 가변인수는 컴파일러가 모든 타입을 받을 수 있도록 Object 배열로 생성한다.

따라서 Object 가 다른 매개변수 타입으로 형변환 할 때 예외가 발생한다.

`EX) String 배열은 은 Object 배열이 될 수 있지만 Object 배열은 String 배열이 될 수 없다.`

#### 해결방법

- varargs 매개변수 배열에 아무것도 저장하지 않는다.
- 그 배열(혹은 복제본)을 신뢰할 수 없는 코드에 노출하지 않는다.



