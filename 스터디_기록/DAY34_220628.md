## 22.06.28

### 학습 내용

- 아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라
  - p.414) 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
  - p.418) synchronized 한정자를 붙이면 안전 실패 문제가 해결된다.
  - 동기화를 위해 메서드에서는 synchronized 키워드를 사용하고, 필드에서는 java.util.concurent.atomic 패키지를 사용하자.
  - 아니면 가변 데이터는 단일 스레드에서만 쓰자.

- 아이템 79. 과도한 동기화는 피하라
  - 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 예측할 수 없는 동작을 낳는다.
  - 재진입락은 응답 불가(교착상태)가 될 상황을 안전 실패(데이터 훼손)로 변모시킬 수도 있다.
    - 교착 상태인 경우 외계인 메서드를 동기화 블록 밖으로 옮기면 된다.
    - 안절 실패인 경우 방어적 복사 또는 동시성 컬렉션 라이브러리(CopyOnWriteArrayList)를 사용하면 된다.

#### 궁금했던 내용들

- 아이템 78
  - p.414) long과 double 외의 변수를 읽고 쓰는 동작이 원자적이다.
    - 원자적이라는 것의 의미?
    - [Writing long and double is not atomic in Java?](https://stackoverflow.com/questions/517532/writing-long-and-double-is-not-atomic-in-java)
  - p.416) 끌어올리기(hoisting)라는 최적화 기법 ? 
  - p.417) volatile 키워드는 항상 가장 최근에 기록된 값을 읽게 됨을 보장한다.
  - p.419) 사실상 불변, 안전 발행
    - 객체를 다시 수정할 일이 생기기 전까지 다른 스레드들은 동기화 없이 자유롭게 값을 읽어갈 수 있다.

- 아이템 79
  - p.421) '|=' 연산자 -> 비교(OR) 연산 + 대입 연산
  - p.420) 외계인 메서드
  - p.424) 재진입락
  - p.426) StringBuilder vs StringBuffer 

