## item28 배열보다는 리스트를 사용하라

### 배열과 제네릭 타입의 차이
- 배열 
  - 공변이다
  - `Sub` 가 `Super` 의 하위 타입이라면배열 `Sub[]`은 `Super[]`의 하위 타입이다
  - 타입 오류 시 런타임 시 오류를 파악할 수 있다
  - ```java
    Object[] objectArray = new Long[1]; //공변이기 때문에 가능하다(Long[].class)
    objectArray[0] = "하이하이^^"; //runtime error! ArrayStoreException
    ```
  - 실체화(reify) 된다
    - 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다(위의 예제 코드 참고)
  - 
- 제네릭 타입
  - 불공변이다
  - `List<Type1>` 과 `List<Type2>`은 하위도 아니고 상위 타입도 아니다 
  - 타입 오류 시 컴파일 중에 오류를 파악할 수 있다
  - ```java
    List<Object> objectList = new ArrayList<Long>();
    objectList.add("컴파일 시점에서 오류를 파악할 수 있습니다");
    ```
  - 실체화 불가 타입이다 ex) `E`, `List<E>`, `List<String>`
    - 런타임 시 타입 정보가 제거된다 => 따라서 컴파일 시 오류를 반환해야 한다 
  

### 제네릭과 가변인수 메서드 
- 가변인수를 담을 배열이 만들어지는데 배열의 원소가 실체화 불가 타입이라면 경고를 발생한다
  - => `@SafeVarargs` 어노테이션으로 경고를 대처할 수 있다

### 정리
- 배열은 공변이고 실체화되는 반면에, 제네릭은 불공변이고 타입 정보가 소거된다.
- 배열은 런타임 시점에서야 오류를 파악할 수 있지만 타입 안정성을 가지는 제네릭은 컴파일 시점에 오류를 파악할 수 있다 
- 그렇기 떄문에 배열보다는 리스트 사용을 권장한다
