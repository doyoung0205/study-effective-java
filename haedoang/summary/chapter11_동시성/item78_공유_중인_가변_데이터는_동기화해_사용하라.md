## item78 공유 중인 가변 데이터는 동기화해 사용하라

### synchronized 
- 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한디
- 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다
- 자바 언어 명세상 `long`과 `double` 외의 변수를 읽고 쓰는 동작은 원자적이다
  - 여러 스레드가 같은 변수를 동기화 없이 수정하는 중이라도 항상 정상적으로 저장한 값을 온전히 읽어옴을 보장한다
  - 단, 한 스레드가 저장한 값이 다른 스레드에게 `보이는가`는 보장하지 않는다

### 동기화는 배타적 실행 뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다


### Thread.stop은 사용하지 말자
- 다른 스레드를 멈추는 메서드로 11버전 이후로 제거되었다
1. `동기화`를 통해 스레드를 안전하게 종료할 수 있다
  - `synchronized`
  - 읽기와 쓰기 모두 동기화되지 않으면 동작을 보장하지 않는다
2. `volatile` 을 사용하는 경우 동기화를 생략할 수 있다.
  - 동기화 방식보다 속도가 더 빠르다

### volatile 사용 시 주의할 점
- 증감 연산자의 사용(++, --)
  - 값을 읽고, 변경하기 때문에 필드에 두번 접근하게 된다
  - 스레드가 동시에 접근할 경우 이전 스레드와 같은 값을 돌려받을 수 있다

### Atomic- class의 사용
- `java.util.concurrent.atomic` 패키지의 클래스들은 락 없이도 스레드 안전하다(lock-free)
  ```java
  private static final AtomicLong nextSerialNum = new AtomicLong();
  
  public static long generateSerialNum() {
      return nextSerialNum.getAndIncrement();
  }
  ```
  
### 가변 데이터는 단일 스레드에서만 사용하자


### 정리
- 여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다
- 동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수 있다
- 공유되는 가변 데이터를 동기화하는 데 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다
  - 디버깅하기 어렵다
- 배타적 실행은 필요하지 않고 스레드 간의 통신이 필요하다면 `volatile` 한정자만으로 동기화 할 수 있다