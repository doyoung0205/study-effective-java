## 프로그램의 동작을 스레드 스케줄러에 기대지 말라
- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다 


### 스레드는 당장 처리해야할 작업이 없다면 실행돼서는 안 된다
- 스레드 풀 크기를 적절히 설정하고, 절대 바쁜 대기(busy waiting) 상태가 되지 않도록 해야 한다

### Thread.yield()
- documentation 내용
  - 현재 스레드가 프로세서의 현재 사용을 기꺼이 양보할 의향이 있다는 스케줄러에 대한 힌트입니다. 
  - 스케줄러는 이 힌트를 무시해도 됩니다.
  - Yield는 CPU를 과도하게 사용하는 스레드 간의 상대적 진행을 개선하기 위한 경험적 시도입니다. 
  - 실제로 원하는 효과를 얻을 수 있도록 상세한 프로파일링 및 벤치마킹과 함께 사용되어야 합니다. 
  - 이 방법을 사용하는 것은 거의 적절하지 않습니다. 
  - 경쟁 조건으로 인한 버그를 재현하는 데 도움이 될 수 있는 디버깅 또는 테스트 목적에 유용할 수 있습니다.
  - java.util.concurrent.locks 패키지에 있는 것과 같은 동시성 제어 구성을 설계할 때도 유용할 수 있습니다.
- yield() 사용이 좋지 못한 이유
  - [https://stackoverflow.com/questions/31011376/thread-yield-considered-harmful](https://stackoverflow.com/questions/31011376/thread-yield-considered-harmful)


### 정리 
- 프로그램의 동작을 스레드 스케줄러에 기대지 말자
- `Thread.yield`와 스레드 우선순위에 의존하지 말자