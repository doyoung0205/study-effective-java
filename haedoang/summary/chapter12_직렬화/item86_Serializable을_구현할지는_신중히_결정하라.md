## item86 Serializable을 구현할지는 신중히 결정하라

### Serializable 을 구현하면 릴리스한 뒤에는 수정하기 어렵다
- 직렬화된 바이트 스트림 인코딩도 공개 API가 된다
- 기본 직렬화 형태에서는 클래스의 private과 package-private 인스턴스 필드 마저 API로 공개된다
  - 캡슐화가 깨짐


### 직렬 버전 UID(serial version UID) 
- 스트림 고유 식별자
- 명시하지 않는 경우 시스템이 런타임에 암호 해시 함수(SHA-1)을 적용해 자동으로 클래스 안에 생성해 넣는다
  - 객체가 변하는 경우 직렬 버전 UI 값도 변하게 되어 호환성이 깨져버린다. `InvalidClassException`
  
### Serializable 구현은 버그와 보안 구멍이 생길 위험이 높아진다
- 직렬화는 기본 메커니즘을 우회하는 객체 생성 기법이다
  - 숨은 생성자
- 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 노출될 수 있다


### Serializable 구현은 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다
- 구버전 인스턴스와의 직렬화, 역직렬화 가능 여부를 점검해야 한다

### Serializable 구현 어부는 가볍게 결정할 사안이 아니다
- `BigInteger`, `Instant` 같은 `값` 클래스와 컬렉션 클래스는 `Serializable` 을 구현한다
- 스레드 풀 처럼 `동작` 하는 객체를 표현하는 클래스는 대부분 구현하지 않았다


### 상속용으로 설계된 클래스는 대부분 Serializable 을 구현하면 안 되며, 인터페이스도 Serializable을 확장해서는 안 된다
- Throwable, Component 는 예외적으로 `Serializable` 을 구현한 상속용 설계 클래스이다
  - Throwable: 서버가 RMI를 통해 클라이언트로 예외를 보내기 위해 구현하였다
  - Component: GUI를 전송하고 저장하고 복원하기 위해 구현하였다. 

### 클래스의 인스턴스 필드가 직렬화와 확장이 가능한 경우 주의사항
- 인스턴스 필드 값 중 불변식을 보장할 게 있다면 하위 클래스에서 `finalize` 를 재정의하지 못하게 해야 한다
  - 자신이 재정의하여 `final`로 선언한다
  - `finalizer` 공격이 발생할 우려가 있음
- 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있는 경우
  - `readObjectNoData` 메서드를 추가해야 한다
  - 상태가 있고, 확장 가능하고, 직렬화 가능한 클래스에 대해서 필수적이다

### 내부 클래스는 직렬화를 구현하지 말아야 한다
- 내부 클래스에 대한 기본 직렬화 형태는 분명하지가 않다. 
  - 단, 정적 멤버 클래스는 `Serializable` 을 구현해도 된다


### 정리
- `Serializable` 을 구현하기는 아주 쉽지만 신중하게 사용해야 한다
  - 상속의 경우 주의할 점이 더 많아진다