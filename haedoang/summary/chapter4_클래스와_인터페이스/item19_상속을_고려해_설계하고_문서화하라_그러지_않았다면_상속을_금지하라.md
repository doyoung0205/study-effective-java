### item 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다
  - `@implSpec` 자바독 도구로 재정의 시 주의할 사항을 명시해두자 
- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개할 수 도 있다
  - `java.util.AbstractList` 의 `removeRange`는 재정의 가능하게 제공된다. => 성능을 개선할 수 있도록 제공해주는 것 
  - 위와 같이 재정의를 통해 성능을 개선하거나 재정의해야만 하는 경우라면 protected로 노출하고 그 이외는 공개하지 않는다
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 보는 것이 유일하다
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다
- 상속용 클래스의 `생성자는 직접적으로든 간접적으로든 재정의 가능 메서드`를 호출해서는 안된다
- clone 과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다
  - readObject: 하위 클래스의 상태가 역직렬화 되기 전에 재정의 메서드 부터 호출된다
  - clone: 하위 클래스의 clone 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출한다 
- Serializable을 구현한 상속용 클래스가 `readResolve`나  `writeReplace` 메서드를 갖는다면 이 메서드들은 private이 아닌 `protected`로 선언해야 한다
  - private 로 선언한다면 하위 클래스에서 무시된다


#### 상속용으로 설계하지 않는 클래스는 상속을 금지하자
 - final 클래스의 사용
 - 모든 생성자를 private 또는 package-private로 선언하고 `정적 팩터리 메서드`를 제공한다
 - 재정의 가능 메서드는 `private 도우미 메서드` 로 옮긴다
