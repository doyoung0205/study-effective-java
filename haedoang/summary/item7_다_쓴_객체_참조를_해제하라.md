### 아이템7 다 쓴 객체 참조를 해제하라
- 자바는 사용하지 않는 객체(참조되지 않은)를 가비지 컬렉터에 의해 메모리상에서 제거가 된다
- 이와 같은 조건은 `참조되지 않은` 객체이어야 한다라는 뜻이다
- 따라서 다 쓴 객체를 참조하는 경우 불필요한 객체가 메모리 상에 계속 남아있어 성능 저하의 원인이 될 수 있다

#### 다 쓴 객체를 참조하는 경우들
- Stack: 스택은 비활성영역에 대한 부분을 참조 제거를 해주어야 한다(가비지 컬렉터가 비활성 영역을 알 수 없기 떄문)
- 캐시: 캐시(일회성)에서의 참조 또한 성능 저하의 원인이 된다. `WeakHashMap`은 사용 즉시 메모리 상에서 제거된다 
- 리스너 또는 콜백: 클라이언트가 콜백을 등록하고 해지하지 않는다면 콜백은 계속 쌓인다. 콜백을 약한 참조로 저장하여 수거 대상이 되도록 해야 한다(`WeakHashMap`의 키로 사용한다)

#### WeakHashMap 이란?
 - `약한 참조` 유형의 키가 있는 Map 인터페이스의 해시 테이블 기반. 
 - 키가 더 이상 일반적으로 사용되지 않을 떄 자동으로 제거(메모리상에서)된다
 
#### 자바의 참조 유형
##### Strong References(강한 참조)
```text
    Integer prime = 1;
```
 - 가비지 컬렉터 수거 대상이 아니다

##### Soft References(소프트 참조)
```text 
    Integer prime = 1;
    SoftReferences<Integer> soft = new SoftReferences<Integer>(prime);
    prime = null;
```
 - JVM 메모리가 필요한 경우에만 gc 대상이 된다

##### Weak References(약한 참조)
```text
    Integer prime = 1;  
    WeakReference<Integer> soft = new WeakReference<Integer>(prime); 
    prime = null;
```
 - 참조가 없는 즉시 gc 수거 대상이 된다. WeakReference 유형의 참조는 WeakHashMap에서 키로 사용한다


#### 콜백 & 리스너 란? 
##### callback
 - 다른 함수에 인수로 전달되는 함수, 이벤트 이후 실행되는 것.
 - 다른 클래스에서 일부 작업이 완료되었을 경우 클래스에 완료되었다는 것을 알려준다(후처리 역할)
 
##### listener 
 - 이벤트를 처리하는 인터페이스. 이벤트 발생 여부를 기다리다가(listen) 이벤트 발생시 처리한다
 - ex) 스프링 프레임워크
   - `ApplciationEvent`: 이벤트 구현
   - `ApplicationListener`: 이벤트 수신 구현 
   - `ApplicationEventPublisher`이벤트 발생 구현

#### 콜백과 리스너의 차이점
 - 콜백은 이벤트가 발생할 때 특정 메서드를 호출해 알려준다(1개)
 - 리스너는 이벤트가 발생할 경우 연결된 리스너에게 이벤트를 전달한다(1개 이상)
 
#### 결론 
- 콜백과 리스너는 호출에 의해 사용이 결정된다. 
- 따라서 사용이 보장되지 않은 콜백과 리스너의 경우 가비지 컬렉터의 수거 대상이 되지 않기 때문에 성능 저하의 요인이 된다.
- 콜백과 리스너를 약한 참조를 통해 사용하면 gc 수거 대상이 된다
