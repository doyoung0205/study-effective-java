# 클래스와 인터페이스

[아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라](#상속을-고려해-설계하고-문서화하라)   
[- 효율적인 하위 클래스를 만들기](#효율적인-하위-클래스를-만들기)   
[- 상속을 허용하는 클래스가 지켜야할 제약사항](#상속을-허용하는-클래스가-지켜야할-제약사항)   
[- 상속을 금지하는 방법](#상속을-금지하는-방법)   
[- 정리](#정리)   

<br>

## 상속을 고려해 설계하고 문서화하라
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
  - 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있다.    
    그런데 마침 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다.
  - 더 넓게 말하면, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.  
    예를 들어 백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어날 수 있다.

- API 문서의 메서드 설명 끝에 종종 "Implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.
    - 이 절은 메서드 주석에 `@implSpec` 태크를 붙여주면 자바독 도구가 생성해준다.
    - 이 태그를 활성화하려면 명령줄 매개변수로 `-tag "implSpec:a:Implementation Requirements:"` 를 지정해주면 된다.


### 효율적인 하위 클래스를 만들기
- 클래스 내부 동작 과정 중간에 끼어들 수 있는 훅(hock)을 잘 선별하려 `protected 메서드` 형태로 공개해야 할 수도 있다.
> 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드를 훅 메서드(hock method)라고 부른다.  
> − 오브젝트, 조영호 (p.360)

- 드물게는 `protected 필드`로 공개해야 할 수도 있다. 
  - java.util.AbstractList 의 removeRange 메서드
    ```java
    protected void removeRange(int fromIndex, int toIndex)
    ```
  - 이 메서드를 제공한 이유는 하위 클래스에서 부분리스트의 clear 메서드를 고성능으로 만들기 쉽게 하기 위해서이다. 

- **protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 한 적어야 한다. 한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다.**

- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.  
  꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러난다.  
  반대로 하위 클래스를 여러개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private 이었어야 할 가능성이 크다.

- 상속용으로 설계한다면 문서화한 내부 사용 패턴과 protected 메서드와 필드를 구현한 결정에 영원히 책임을 져야함을 인식해야 한다.


### 상속을 허용하는 클래스가 지켜야할 제약사항
1. **상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.**
    - 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 **하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.**
    - 상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 상위 생성자에서 사용된 메서드를 호출하기 때문이다.
    ```java
    public class Super {
      public Super() { // 생성자가 재정의 가능 메서드를 호출
          overrideMe();
      }
    
      public void overrideMe() {
      }
    }
    ```
    ```java
    public final class Sub extends Super {
      private final Instant instant ;
 
      public Sub() {
          this.instant = Instant.now();
       }
 
      @Override
      public void overrideMe() { // 재정의 메서드. 상위 클래스의 생성자가 호출
          System.out.println(instant);
      }
    }
    ```
    - 상위 클래스의 생성자에서 overrideMe를 호출할 때는 `NullpointException을` 던지게 된다.


2. `Cloneable`, `Serialisable` 인터페이스를 구현한 클래스는 일반적으로 상속용으로 설계하지 않는다.
    - `clone`과 `readObject` 메서드는 생성자와 비슷한 효과를 낸다.  
      \- `clone` 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출한다.     
      \- `readObject` 메서드가 하위 클래스의 상태가 역직렬화되기 전에 재정의한 메서드를 호출한다.
    - `clone`과 `readObject` 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.


3. `Serialisable`을 구현한 상속용 클래스가 `readResolve`나 `writeReplace` 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 한다. (private 으로 선언하면 하위 클래스에서 무시되기 때문이다.)


### 상속을 금지하는 방법
1. 클래스를 `final`로 선언하는 방법
2. 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만드는 방법


### 정리
- 상속을 금지하더라도, 핵심 기능을 정의한 인터페이스 있다면 개발하는데 아무런 어려움이 없다.
- 기능을 증강할 목적이라면 상속 대신 래퍼 클래스를 쓰는 것이 더 나은 대안이다.
- 상속을 사용한다면, 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고, 이를 문서화 해야 한다.


<br>

