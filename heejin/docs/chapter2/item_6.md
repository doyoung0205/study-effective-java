# 객체 생성과 파괴

[아이템 6. 불필요한 객체 생성을 피하라](#불필요한-객체-생성을-피하라)  
[- 생성 비용이 비싼 객체](#생성-비용이-비싼-객체)  
[- 오토박싱](#오토박싱)  

<br>

## 불필요한 객체 생성을 피하라
- 똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다.


### 생성 비용이 비싼 객체 
  - 이 코드는 실행될 때마다 String 인스턴스 새로 만든다.
    ```java
    String s = new String("bikini");
    ```

  - 이 코드는 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다.
    ```java
    String s = "bikini";
    ```

- 생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다. *(→ item 1)*
  - `Boolean("true")` 생성자 대신 `Boolean.valueOf("true")` 팩터리 메서드를 사용하는 것이 좋다.
  

- 불변 객체만이 아니라 가변 객체라도 사용 중에 변경되지 않을 것임을 안다면 재사용할 수 있다.
- **생성 비용이 비싼 객체는 캐싱하여 재사용하길 권한다.**
        
  ```java
  public static boolean isRomanNumber(String s) {
        return s.matches("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
  }
  ```
  - String.matches 는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다.
  
  ```java
  private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

  public static boolean isRomanNumber(String s) {
      return ROMAN.matcher(s).matches();
  }
  ```
  
  - 개선된 코드는 성능이 좋아진 것뿐만 아니라 코드도 더 명확해졌다.
  - 하지만, 이 메서드를 한 번도 호출하지 않는다면 `ROMAN` 필드는 쓸데없이 초기화된다.
  - `isRomanNumber` 메서드가 처음 호출될 때 필드를 초기화하는 지연 초기화로 불필요한 초기화를 없앨 수는 있지만, 권하지 않는다. *(→ item 83)*
  - 지연 초기화는 코드를 복잡하게 만드는데, 성능은 크게 개선되지 않을 때가 많기 때문이다. *(→ item 67)*


### 오토박싱
- 오토박싱 역시 불필요한 객체를 만들어낸다. 
- 오토박싱은 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술이다.
- 의미상으로는 별다를 것 없지만 성능상에서는 그렇지 않다. *(→ item 61)*

  ```java
  public static long sum() {
      Long sum = 0L;
      for (int i = 0; i < Integer.MAX_VALUE; i++) {
          sum += i;
      }
      return sum;
  }
  ```
  - `sum` 변수를 `long`이 아닌 `Long`으로 선언해서 불필요한 Long 인스턴스가 약 2^31 개나 만들어진다.

- **박싱된 기본 타입보다는 기본 타입을 사용하고, 의도하지 않은 오토박싱이 숨어들지 않도록 주의하자.**


### 방어적 복사
- 이번 아이템을 "객체 생성은 비싸니 피애햐 한다"로 오해하면 안된다.
- 요즘의 JVM에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않는다.
- 거꾸로, 아주 무거운 객체가 아니라면 객체 풀(pool)을 만들지 말아야 한다. 
  - 데이터베이스 연결 같은 경우 생성 비용이 워낙 비싸니 재사용하는 편이 낫다.
  - 하지만, 일반적으로 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다.


- 이번 아이템은 방어적 복사와 대조적이다. *(→ item 50)*
  - [item 6] 기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라
  - [item 50] 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라


- 방어적 복사가 필요한 상황에서 객체를 재사용하면 언제 터져 나올지 모르는 버그와 보안에 구멍이 생길 수 있다.
- 반면, 방어적 복사가 필요한 상황에서 불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 준다. 

        
<br>
