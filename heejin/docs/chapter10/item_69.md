# 예외

[아이템 69. 예외는 진짜 예외 상황에만 사용하라](#예외는-진짜-예외-상황에만-사용하라)  
[- 반복문에서 예외 대신 사용할 수 있는 선택](#반복문에서-예외-대신-사용할-수-있는-선택)  

<br>

## 예외는 진짜 예외 상황에만 사용하라
- 예외는 오직 예외 상황에서만 써야 한다.
- **절대로 일상적인 제어 흐름용으로 쓰여선 안된다.**
  - 예외는 예외 상황에 쓸 용도로 설계되었기 때문에 속도를 빠르게 최적화하는 것에는 신경쓰지 않았을 가능성이 크다.  
    → 실제로 예외를 사용할 쪽이 표준 관용구보다 훨씬 느리다. 
  - 코드를 `try-catch` 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
  - 배열을 순회하는 표준 관용구는 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다.
- 또한, **잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.**

####  예외를 제어 흐름으로 사용한 예
- 예외를 잘못 사용한 예
    ```java
    try {
        int i = 0;
        while (true) {  // 무한루프를 돌다가 배열의 끝에 도달해 예외 발생
            range[i++].climb();
        }
    } catch (ArrayIndexOutOfBoundsException e) {
    }
    ```

- 예외 대신 표준 관용구를 사용한 예
    ```java
    for (Mountain m : range) {
        m.climb();
    }
    ```
<br>

### 반복문에서 예외 대신 사용할 수 있는 선택
반복문에서 예외를 사용하면 장황하고 헷갈리며 속도도 느리고, 엉뚱한 곳에서 발생한 버그를 숨기기도 한다. 

1. **상태 검사 메서드**
   - eg. `Iterator` 인터페이스의 `hasNext`(상태 검사 메서드), `next`(상태 의존 메서드)
2. **옵셔널**
3. **특정 값 (default)** 
   - eg. `null`

#### 예외 대신 사용할 수 있는 선택의 지침
- 외부 동기화 없이 **여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할수 있다면** 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.
- **성능이 중요한 상황**에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
- 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다. 가독성이 더 좋고, 잘못 사용했을 때 발견하기가 쉽다.

<br>
