# 제네릭

[아이템 28. 배열보다는 리스트를 사용하라](#배열보다는-리스트를-사용하라)
[- 배열과 제네릭 타입의 차이](#배열과-제네릭-타입의-차이)
[- 제네릭의 사용](#제네릭의-사용)
[- 정리](#정리)
<br>

## 배열보다는 리스트를 사용하라

### 배열과 제네릭 타입의 차이
아래의 두 차이로 인해 배열과 제네릭은 잘 어우러지지 못한다. 

1. 배열은 공변이고, 제네릭은 불공변이다.
  - 공변이란, 함께 변한다는 뜻이다.
  - Sub가 Suber의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다.
  - 하지만 제네릭의 List<Type1>과 List<Type2>는 하위 타입이나 상위 타입이 아니다.

  ```java
  Object[] objectArrray = new Long[1];
  // 런타임에 ArrayStoreException 을 던진다.
  objectArrray[0] = "타입이 달라 넣을 수 없다.";

  // 호환되지 않는 타입니다. 컴파일 시점에 에러가 표시된다.
  List<Object> objectList = new ArrayList<Long>();
  objectList.add("타입이 달라 넣을 수 없다.");
  ```
  - 이 코드는 어느 쪽이든 Long용 저장소에 String을 넣을 수 없다. 
  - 다반 배열에서는 그 실수를 런타임에야 알게 되지만, 리스트를 사용하면 컴파일할 때 바로 알 수 있다.

2. 배열은 실체화 되지만, 제네릭은 소거된다.
    - 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
    - 제네릭은 타입 정보가 런타임에는 소거 된다. 원소 타입을 컴파일에만 검사하며 런타임에는 알수조차 없다는 뜻이다.
      - 소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭이 순조롭게 전환될 수 있도록 해준다. *(→ item 26)*
    

### 제네릭의 사용
- 제네릭이 배열을 만들지 못하게 한 이유는 타입 안전하지 않기 때문이다.
  - 배열을 사용하면 컴파일러가 자동 생성한 형변환 코드에용 런타임에 `ClassCastException이` 발생할 수 있다.

- `E`, `List<E>`, `List<String>` 과 같은 타입을 실체화 불가 타입이라고 한다.
  - 즉, 실체화 되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다.
  - 소거 매커니즘 때문에 매개변수화 타입 가운데 실체화 될 수 있는 타입은 `List<?`>와 `Map<?,?>` 같은 비한정적 와일드카드 타입뿐이다. *(→ item 26)*

- 배열을 제네릭으로 만들 수 없어서 귀찮을 때도 있다.
  - 예컨데, 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는게 보통은 불가능하다.
  - 이 문제를 해결해주는 방법은 아이템 33에서 설명한다. *(→ item 33. 타입 안전 이종 컨테이너)*
  
- 또한 제네릭 타입과 가변인수 메서드를 함께 쓰면 해석하기 어려운 경고 메시지를 받게 된다. 
  - 가변인수 메서드를 호출할 때마다 가변인수 매개변수를 담을 배열이 하나 만들어지는데, 이때 그 배열의 원소가 실체화 불가 타입이라면 경고가 발생하는 것이다.
  - 이 문제는 `@SafeVarargs` 애너테이션으로 대처할 수 있다.
  ```java
  @SafeVarargs
  @SuppressWarnings("varargs")
  public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
  }
  ```


### 정리
- 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
- 배열은 공변이고, 실체화 된다.
- 제네릭인 불공변이고, 타입 정보가 소거된다.
- 그 결과 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않다.
- 반대로 제네릭은 컴파일타임에 타입 안전성을 확인할 수 있다.


<br>

