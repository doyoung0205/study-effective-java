# 동시성

[아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라](#공유-중인-가변-데이터는-동기화해-사용하라)
[- 공유 가변 데이터](#공유-가변-데이터)   
[- volatile 사용 시 주의사항](#volatile-사용-시-주의사항)   
[- 동기화의 적절한 사용](#동기화의-적절한-사용)   
[- 정리](#정리)

<br>

## 공유 중인 가변 데이터는 동기화해 사용하라
- `synchronized` 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다.

- 동기화의 주요 개념 중 하나가 배타적 실행이다.
  - 동기화를 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다.
- 하지만, 동기화에는 중요한 기능이 하나 더 있다.
  - 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.
  
- 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메서드나 블록에 들어간 스레드가 같은 락에서 수행된 상태의 최종 결과를 보게 해준다.  
  **➡️ 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.**


### 공유 가변 데이터
- 변수를 읽고 쓰는 동작은 원자적이다. (long, double 제외)
  - 즉, 여러 스레드가 같은 변수를 동기화 없이 수정하는 중이라도, 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장한다.
- 그렇다고 원자적 데이터를 읽고 쓸 때 동기화 하지 않아도 된는 것은 아니다.
  - 자바 언어는 스레드가 필드를 읽을 때 항상 '수정이 완전히 반영된'값을 얻는다고 보장하지만, 스레드가 저장한 값이 다른 스레드에게 '보이는가'는 보장하지 않는다.
  - 그래서 공유 중인 가변 데이터를 원자적으로 읽고 쓸 수 있을지라도 동기화에 실패하면 결과가 달라질 수 있다.

- [공유 가변 데이터의 문제](../../src/main/java/study/heejin/chapter11/StopThread.java)
  - 동기화하지 않으면 메인 스레드가 수정한 값을 백그라운드 스레드가 언제 보게 될지 보증할 수 없다.
  - 그래서 동기화가 빠지면 OpenJDK 서버 VM이 끌어올리기라는 최적화 기법을 적용하게 되어 프로그램이 응답불가 상태가 될 수 있다. 
- [공유 가변 데이터의 문제 해결 - 쓰기와 읽기 메서드 동기화](../../src/main/java/study/heejin/chapter11/StopThreadSyncronized.java)
  - 쓰기와 읽기 모두가 동기화하면 기대한 결과를 얻을 수 있다.
  - 동기화는 배타적 수행과 스레드 간 통신이라는 두 가지 기능을 수행하는데, 이 코드에서는 그중 통신 목적으로만 사용되었다.
- [공유 가변 데이터의 문제 해결 - volatile](../../src/main/java/study/heejin/chapter11/StopThreadVolatile.java)
  - `volatile` 한정자는 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장한다.
  

### volatile 사용 시 주의사항
- [volatile 사용 - 안전실패](../../src/main/java/study/heejin/chapter11/VolatileSerialNumber.java)
  - 증가 연산자(++)는 코드상으로는 하나지만 실제로는 필드에 두 번 접근하여 문제가 생길 수 있다.
  - 프로그램이 잘못된 결과를 계산해내는 오류를 **안전 실패**라고 한다.
- [volatile 사용 - synchronized 메서드](../../src/main/java/study/heejin/chapter11/VolatileSerialNumberSynchronized.java)
  - 메서드에 `synchronized` 한정자를 붙이면 동시에 호출해도 서로 간섭하지 않고 이전 호출에서 변경한 값을 읽게 된다. 이때 필드에서는 `volatile`은 제거해야 한다.
- [volatile 사용 - automic](../../src/main/java/study/heejin/chapter11/VolatileSerialNumberAutomic.java)
  - `java.util.concurrent.atomic` 패키지에는 락 없이도 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨있다. 
  - `volatile`은 동기화의 두 효과 중 통신 쪽만 지원하지만 이 패키지는 원자성(배타적 실행)까지 지원한다.


### 동기화의 적절한 사용
- 동기화 문제를 피하는 가장 좋은 방법은 애초에 가변 데이터를 공유하지 않는 것이다.
  - 불변 데이터만 공유하거나 아무것도 공유하지 말자.
  - 가변 데이터는 단일 스레드에서만 쓰자.
- 동기화에서 사실상 불변 객체와 안전 발행을 생각하자.
  - **사실상 불변 객체**란, 한 스레드가 데이터를 다 수정한 후 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화하는 것이다.  
    그러면 해당 객체를 다시 수정할 일이 생기기 전까지다른 스레드들은 동기화 없이 자유롭게 값을 읽을 수 있다.
  - **안전 발행**이란, 사실상 불변인 객체를 다른 스레드에 건네는 행위이다.   
    - 객체를 안전하게 발행하기 위한 방법  
      클래스 초기화 과정에서 객체를 정적 필드, `volatile` 필드, `final` 필드, 혹은 보통의 락을 통해 접근하는 필드에 저장해도 된다. 그리고 동시성 컬렉션에 저장하는 방법도 있다.


### 정리
- **여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.**
- 공유되는 가변 데이터를 동기화하는 데 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다. 

<br>
