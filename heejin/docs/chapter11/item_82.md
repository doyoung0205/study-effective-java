# 동시성

[아이템 82. 스레드 안전성 수준을 문서화하라](#스레드-안전성-수준을-문서화하라)  

[- 스레드 안전성 수준](#스레드-안전성-수준)  
[- 스레드 안전성 애너테이션](#스레드-안전성-애너테이션)  
[- 문서화](#문서화)  
[- 비공개 락](#비공개-락)      
[- 정리](#정리)    

<br>

## 스레드 안전성 수준을 문서화하라
- 자바독 기본 옵션에서 생성한 API 문서에는 synchronized 한정자가 포함되지 않는다.
- 메서드 선언에 synchronized 한정자를 선언할지는 구현 이슈일 뿐 API에 속하지 않는다. 
- 멀티스레드 환경에서도 API를 안전하게 사용하려면, 클래스가 지원하는 스레드 안전성 수준을 전확히 명시해야 한다.

### 스레드 안전성 수준
- 불변
  - 이 클래스의 인스턴스는 마치 상수와 같아서 외부 동기화가 필요 없다.
  - ex) `String`, `Long`, `BigInteger`
- 무조건적 스레드 안전
  - 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전하다.
  - ex) `AtomicLong`, `ConcurrentHashMap` 
- 조건부 스레드 안전
  - 무조건적 스레드 안전과 같으나, 일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다.
  - ex) `Collections.synchronized` 래퍼 메서드가 반환한 컬렉션
- 스레드 안전하지 않음
  - 이 클래스의 인스턴스는 수정될 수 있다. 동시에 사용하려면 메서드 호출을 외부 동기화 메커니즘으로 감싸야 한다.
  - ex) `ArrayList`, `HashMap`
- 스레드 적대적
  - 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다.
  - 스레드 적대적으로 밝혀진 클래스나 메서드는 일반적으로 문제를 고쳐 재배포하거나 사용 자제(deprecated) API로 지정한다.

### 스레드 안전성 애너테이션
- 자바 병렬 프로그래밍
  - `@Immutable` : 불변
  - `@ThreadSafe` : 무조건적 스레스 안전, 조건부 스레드 안전
  - `@NotThreadSafe` : 스레드 안전하지 않음, 스레드 적대적

### 문서화
- 조건부 스레드 안전한 클래스는 주의해서 문서화해야 한다.
  - 어떤 순서로 호출할 때 외부 동기화가 필요한지, 그 순서로 호출하려면 어떤 락을 얻어야 하는지 알려줘야 한다.
  - 일반적으로 인스턴스 자체를 락으로 얻지만 예외도 있다.
  
    <details>
    <summary>예를 들어, Collections.synchronizedMap의 API 문서에는 다음과 같이 써있다.</summary>
    <div markdown="1">
    
    ```java
    /**
     * 지정된 맵에서 지원하는 동기화된(스레드 세이프) 맵을 반환합니다. 
     * 직렬 액세스를 보장하려면 반환된 맵을 통해 백킹 맵에 대한 모든 액세스를 수행하는 것이 중요합니다.
     * 
     * {@link Iterator}, {@link Splitator} 또는 {@link Stream}을(를) 통해 컬렉션 보기 또는 {@code subMap}, {@code headMap} 또는 {@code tailMap} 
     * 뷰의 컬렉션 보기를 이동할 때 사용자가 수동으로 동기화해야 합니다.
     *
     *  Map m = Collections.synchronizedMap(new HashMap());
     *      ...
     *  Set s = m.keySet();  // Needn't be in synchronized block
     *      ...
     *  synchronized (m) {  // Synchronizing on m, not s!
     *      Iterator i = s.iterator(); // Must be in synchronized block
     *      while (i.hasNext())
     *          foo(i.next());
     *  }
     * 
     * 이 조언을 따르지 않으면 비결정론적 행동을 초래할 수 있습니다.
     * 지정된 맵을 직렬화할 수 있으면 반환된 맵을 직렬화할 수 있습니다.
     */
    public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) {
        return new SynchronizedMap<>(m);
    }
    ```
    </div>
    </details>

  - 클래스에 스레드 안전성은 보통 클래스의 문서화 주석에 기재하지만, 독특한 특성의 메서드라면 해당 메서드의 주석에 기재하도록 하자.

### 비공개 락
- 클래스가 외부에서 사용할 수 있는 락을 제공하면 클라이언트에서 일련의 메서드 호출을 원자적으로 수행할 수 있다.
- 하지만, **동시성 컬렉션**과 혼용해서 사용하지 못하고, 클라이언트가 락을 오래 쥐고 놓지 않는 **서비스 거부 공격**을 수행할 수 있다. 
- 서비스 거부 공격을 막으려면 비공개 락 객체를 사용해야 한다.

  ```java
  private final Object lock = new Object();
  
  public void foo() {
      synchronized (lcok) {
          ...
      }
  }
  ```
  - 비공개 락 객체는 클래스 바깥에서는 볼 수 없으니 클라이언트가 그 객체의 동기화에 관여할 수 없다.
  - 락 객체를 동기화 대상 객체 안으로 캡슐화한 것이다.
  - **락 필드는 항상 final 로 선언하라.**
  - 비공개 락 객체 관용구는 무조건적 스레드 안전 클래스에서만 사용할 수 있다.


### 정리
- 모든 클래스가 자신의 스레드 안전성 정보를 명확히 문서화해야 한다.
- `synchronized` 한정자는 문서화와 관련이 없다.
- 조건부 스레드 안전 클래스는 메서드를 어떤 순서로 호출할 때 외부 동기화가 요구되고, 그대 어떤 락을 얻어야 하는지도 알려줘야 한다.
- 무조건적 스레드 안전 클래스를 작성할 때는 `synchronized` 메서드가 아닌 비공개 락 객체를 사용하자.
- 

<br>
