# 람다와 스트림

[아이템 48. 스트림 병렬화는 주의해서 적용하라](#스트림-병렬화는-주의해서-적용하라)  
[- 스트림 파이프라인을 병렬화하면 안되는 경우](#스트림-파이프라인을-병렬화하면-안되는-경우)  
[- 스트림 파이프라인을 병렬화하면 효과가 좋은 경우](#스트림-파이프라인울-병렬화하면-효과가-좋은-경우)  
[- 스트림 병렬화의 사용](#스트림-병렬화의-사용)  
[- 정리](#정리)  

<br>

## 스트림 병렬화는 주의해서 적용하라
> **병렬 처리(Parallel Operation)**   
> 멀티 코어 환경에서 하나의 작업을 분할해 각각의 코어가 병렬적으로 처리하는 작업이다.

> **동시성과 병렬성**  
> ✓ 동시성(Concurrency)  
> 멀티 작업을 위해 멀티 스레드가 번갈아가며 실행하는 성질이다. 싱글 코어 CPU를 이용한 멀티 작업은 병렬적으로 실행되는 것처럼 보이지만 실제로는 동시성 작업이다.  
> ✓ 병렬성(Parallelism)  
> 병렬성은 멀티 작업을 위해 멀티 코어를 이용해 동시에 실행하는 성질이다. 

- 자바는 다른 언어에 비해 동시성 프로그래밍을 잘 지원하고 있다. 
  - 처음 릴리즈된 1996년부터 스레드, 동기화, `wait/notify`를 지원
  - 자바 5부터 동시성 컬렉션인 `java.util.concurrent` 라이브러리와 실행자(`Executor`) 프레임워크를 지원
  - 자바 7부터 고성능 병렬 분해 프레임워크인 포크-조인 패키지를 추가
  - 자바 8부터 파이프라인을 병렬 실행할 수 있는 스트림을 지원 (`parallel` 메서드)
- 그럼에도 동시성 프로그래밍을 올바르고 빠르게 작성하는 일은 어려운 작업이다.
- 동시성 프로그래밍을 할 때는 안전성(safety)과 응답 가능(liveness) 상태를 유지하기 위해 애써야 한다. 병렬 스트림 파이프라인 프로그래밍에서도 마찬가지이다.

> **포크-조인**  
> 어떤 계산 작업을 할 때 여러 개로 나누어 계산한 후 결과를 모으는 작업을 의미한다.


### 스트림 파이프라인을 병렬화하면 안되는 경우
- 데이터 소스가 `Stream.iterate` 이거나, 중간 연산으로 `limit`를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.
  - 파이프라인 병렬화는 limit를 다룰 때 CPU 코어가 남는다면 원소 몇 개 더 처리한 수 제한된 개수 이후의 결과를 버리게 된다.
  - [메르센 소수의 병렬화 예제](../../src/main/java/study/heejin/chapter7/item48/ParallelMersennePrimes.java)
- 스트림 파이프라인의 종단 연산이 순차적인 연산이라면 파이프라인 병렬 수행의 효과는 제한될 수 밖에 없다.
- 가변 축소를 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 않다.


### 스트림 파이프라인을 병렬화하면 효과가 좋은 경우

#### 1) 병렬화하기 좋은 자료구조
- 스트림의 소스가 `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap`의 인스턴스이거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.

  - 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 일을 다수의 스레드에 분배하기 좋다는 특징이 있다.
    - 나누는 작업은 `Spliterator`가 담당하며, Spliterator 객체는 Stream 이나 Iterable의 spliterator 메서드로 얻어올 수 있다.

  - 원소들을 순차적으로 실행할 때, **참조 지역성**이 좋다는 특징이 있다.
    - 참조 지역성이란 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있는 것이다.
    - 참조 지역성이 가장 뛰어난 자료구조는 기본 타입의 배열이다.
    - 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리게 된다.
    - 참조 지역성은 _다량의 데이터를 처리하는 벌크 연산을 병렬화할 때 아주 중요한 요소로 작용한다._
    
#### 2) 종단 연산 중 병렬화에 적합한 작업
- 파이프라인에서 만들어진 모든 원소를 하나로 합치는 축소 작업은 병렬화에 적합하다.
  - Steream의 `reduce` 메서드, 또는 `min`, `max`, `count`, `sum` 같이 완성된 형태로 제공되는 메서드에 사용할 수 있다.
- 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합하다.
  - `anyMatch`, `allMatch`, `noneMatch` 메서드에 사용할 수 있다.


### 스트림 병렬화의 사용
- 스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.
- 스트림 병렬화는 오직 성능 최적화 수단임을 기억해야 한다.
  - 병렬화 변경 전후로 반드시 성능을 테스트하여 병렬화를 사용할 가치가 있는지 확인해야 한다.
- 조건이 잘 갖춰지면 `parallel` 메서드 호출 하나로 거의 프로게서 코어 수에 비례하여 성능이 향상된다.
  - [병렬화가 적합한 소수 계산 예제](../../src/main/java/study/heejin/chapter7/item48/ParallelPrimeCounting.java)
- 무작위 수들로 이뤄진 스트림을 병렬화할 때는 `ThreadLocalRandom` 보다는 `SplittableRandom` 인스턴스를 사용는 것이 좋다.
  - `ThreadLocalRandom`은 단일 스레드에서 쓰고자 만들어졌다.
  - `SplittableRandom`으로 병렬화하면 성능이 선형으로 증가한다.
  - `Random`은 모든 연산을 동기화하기 때문에 병렬 처리하면 최악의 성능이 나온다.


### 정리
- 스트림을 잘못 병렬화하면 프로그램을 오작동하게 하거나 성능을 급격히 떨어뜨린다.
- 병렬화하는 편이 낫다고 믿더라도, 수정 후의 코드가 여전히 정확한지 확인하고 운영 환경과 유사한 조건에서 수행해보며 성능지표를 유심히 관찰하라.


<br>

#### Reference
- [[Java] 병렬 데이터 처리(병렬 스트림, 포크/조인 프레임워크)](https://girawhale.tistory.com/131)
- [Fork/Join을 알아보자!](https://velog.io/@maketheworldwise/ForkJoin%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)