# 열거 타입과 애너테이션

[아이템 34. int 상수 대신 열거 타입을 사용하라](#int-상수-대신-열거-타입을-사용하라)  
[- 안티 패턴](#안티-패턴)  
[- 열거 타입](#열거-타입)  

<br>

## int 상수 대신 열거 타입을 사용하라
- 열거 타입은 일정 개수의 상수 값을 정의한 다음, 그 외의 값은 허용하지 않는 타입이다.
  - eg. 사계절, 태양계의 행성, 카드게임의 카드 종류 등


### 안티 패턴
#### 1) 정수 열거 패턴
  - 타입 안전을 보장할 방법이 없고, 표현력도 좋지 않다.
  - 정수 열거 타입을 위한 별도 이름공간을 지원하지 않기 때문에 접두어를 써서 이름 충돌을 방지해야 한다.
    - eg. 영어로는 둘 다 mercury인 수은과 수성의 이름을 각각 ELEMENT_MERCURY와 PLANET_MERCURY로 구분해야 한다.
  - 정수 열거 타입은 컴파일하면 그 값이 클라이언트 파일에 그대로 새겨진다. 따라서 상수의 값이 바뀌면 클라이언트도 다시 컴파일해야 한다.

#### 2) 문자열 열거 패턴
  - 문자열 상수의 값을 그대로 하드코딩해야 한다.
  - 하드코딩한 문자열에 오타가 있어도 컴파일러는 확인할 수 없고, 런타임 버그가 생긴다.


### 열거 타입
- 자바의 열거 타입은 완전한 형태의 클래스라서 다른 언어의 열거 타입보다 훨씬 강력하다.
- 열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 `public static final` 필드로 공개한다.
- 클라이언트가 인스턴스를 직접 생성하거나 확장할 수 없기 때문에 열거 타입 인스턴스들은 딱 하나만 존재함이 보장된다.
- 싱글턴은 원소가 하나뿐인 열거 타입이라 할 수 있고, 거꾸로 열거 타입은 싱글턴을 일반화한 형태라고 볼 수 있다.


#### 장점
- 열거 타입은 컴파일타임 타입 안정성을 제공한다.
- 열거 타입에는 각자의 이름공간이 있어서 이름이 같은 상수도 공존할 수 있다.
- 열거 타입에 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다.
- 열거 타입에는 임의의 메서드나 필드를 추가할 수 있고, 인터페이스를 구현하게 할 수도 있다.
  - [데이터와 메서드를 갖는 열거 타입](../../src/main/java/study/heejin/chapter6/item34/Planet.java)


#### 열거 타입의 사용
- 필요한 원소를 컴파일타입에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.
- 널리 쓰이는 열거 타입은 톱레벨 클래스로 만들고, 특정 톱레벨 클래스에서만 쓰인다면 해당 클래스의 멤버 클래스로 만든다.
- **상수별 메서드 구현**
  - 상수마다 동작이 달라져야 하는 상황에서 사용할 수 있다.
  - [사칙 연산 계산기 예제](../../src/main/java/study/heejin/chapter6/item34/Operation.java)
  - 한편, 상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단접이 있다.
- **전략 열거 타입 패턴**
  - 열거 타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사용하자. 
  - 새로운 상수를 추가할 때 전략을 선택하도록 하는 방식이다.
  - [급여명세서 예제](../../src/main/java/study/heejin/chapter6/item34/Operation.java)